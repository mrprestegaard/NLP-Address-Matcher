# Grouped dictionaries for better organization
STREET_ABBREVIATIONS = {
    "alley": "Aly", "annex": "Anx", " arcade": "Arc", "avenue": "Ave", "bayou": "Byu",
    "beach": "Bch", "bend": "Bnd", "bluff": "Blf", "boulevard": "Blvd", "branch": "Br",
    "bridge": "Brg", "brook": "Brk", "burg": "Bg", "bypass": "Byp", "camp": "Cp",
    "canyon": "Cyn", "cape": "Cpe", "causeway": "Cswy", "center": "Ctr", "circle": "Cir",
    "cliff": "Clf", "club": "Clb", "corner": "Cor", "course": "Crs", "court": "Ct",
    "cove": "Cv", "creek": "Crk", "crescent": "Cres", "crossing": "Xing", "dale": "Dl",
    "dam": "Dm", "divide": "Dv", "drive": "Dr", "estate": "Est", "expressway": "Expy",
    "extension": "Ext", "fall": "Fall", "ferry": "Fry", "field": "Fld", "flat": "Flt",
    "ford": "Frd", "forest": "Frst", "forge": "Frg", "fork": "Frk", "fort": "Ft",
    "freeway": "Fwy", "garden": "Gdn", "gateway": "Gtwy", "glen": "Gln", "green": "Grn",
    "grove": "Grv", "harbor": "Hbr", "haven": "Hvn", "heights": "Hts", "highway": "Hwy",
    "hill": "Hl", "hollow": "Holw", "inlet": "Inlt", "island": "Is", "junction": "Jct",
    "key": "Ky", "knoll": "Knl", "lake": "Lk", "landing": "Lndg", "lane": "Ln",
    "light": "Lgt", "loaf": "Lf", "lock": "Lck", "lodge": "Ldg", "manor": "Mnr",
    "meadow": "Mdw", "mill": "Ml", "mission": "Msn", "mount": "Mt", "mountain": "Mtn",
    "neck": "Nck", "orchard": "Orch", "park": "Prk", "parkway": "Pkwy", "pass": "Pass",
    "place": "Pl", "plain": "Pln", "plaza": "Plz", "point": "Pt", "port": "Prt",
    "prairie": "Pr", "radial": "Radl", "ranch": "Rnch", "rapids": "Rpds", "rest": "Rst",
    "ridge": "Rdg", "river": "Riv", "road": "Rd", "route": "Rte", "row": "Row",
    "run": "Run", "shoal": "Shl", "shore": "Shr", "spring": "Spg", "square": "Sq",
    "station": "Sta", "stravenue": "Stra", "stream": "Strm", "street": "St",
    "summit": "Smt", "terrace": "Ter", "trace": "Trce", "track": "Trak", "trail": "Trl",
    "tunnel": "Tunl", "turnpike": "Tpke", "union": "Un", "valley": "Vly", "viaduct": "Via",
    "view": "Vw", "village": "Vlg", "ville": "Vl", "vista": "Vis", "walk": "Walk",
    "way": "Way", "wells": "Wls"
}

UNIT_ABBREVIATIONS = {
    "apartment": "Apt", "building": "Bldg", "department": "Dept", "floor": "Fl",
    "front": "Frnt", "hanger": "Hngr", "lobby": "Lbby", "lot": "Lot", "lower": "Lowr",
    "office": "Ofc", "penthouse": "Ph", "pier": "Pier", "rear": "Rr", "room": "Rm",
    "side": "Side", "slip": "Slip", "space": "Spc", "stop": "Stop", "suite": "Ste",
    "trailer": "Trlr", "unit": "Unit", "upper": "Uppr"
}

DIRECTIONAL_ABBREVIATIONS = {
    "north": "N", "south": "S", "east": "E", "west": "W",
    "northeast": "NE", "northwest": "NW", "southeast": "SE", "southwest": "SW"
}

ORDINAL_ABBREVIATIONS = {
    "first": "1st", "second": "2nd", "third": "3rd", "fourth": "4th",
    "fifth": "5th", "sixth": "6th", "seventh": "7th", "eighth": "8th", "ninth": "9th"
}

# U.S. State Abbreviations
US_STATE_ABBREVIATIONS = {
    "alabama": "AL", "alaska": "AK", "arizona": "AZ", "arkansas": "AR", "california": "CA",
    "colorado": "CO", "connecticut": "CT", "delaware": "DE", "florida": "FL", "georgia": "GA",
    "hawaii": "HI", "idaho": "ID", "illinois": "IL", "indiana": "IN", "iowa": "IA",
    "kansas": "KS", "kentucky": "KY", "louisiana": "LA", "maine": "ME", "maryland": "MD",
    "massachusetts": "MA", "michigan": "MI", "minnesota": "MN", "mississippi": "MS",
    "missouri": "MO", "montana": "MT", "nebraska": "NE", "nevada": "NV", "new hampshire": "NH",
    "new jersey": "NJ", "new mexico": "NM", "new york": "NY", "north carolina": "NC",
    "north dakota": "ND", "ohio": "OH", "oklahoma": "OK", "oregon": "OR", "pennsylvania": "PA",
    "rhode island": "RI", "south carolina": "SC", "south dakota": "SD", "tennessee": "TN",
    "texas": "TX", "utah": "UT", "vermont": "VT", "virginia": "VA", "washington": "WA",
    "west virginia": "WV", "wisconsin": "WI", "wyoming": "WY"
}

# Canadian Province & Territory Abbreviations
CANADIAN_PROVINCE_ABBREVIATIONS = {
    "alberta": "AB", "british columbia": "BC", "manitoba": "MB", "new brunswick": "NB",
    "newfoundland and labrador": "NL", "northwest territories": "NT", "nova scotia": "NS",
    "nunavut": "NU", "ontario": "ON", "prince edward island": "PE", "quebec": "QC",
    "saskatchewan": "SK", "yukon": "YT"
}

# Merge all dictionaries into a single USPS_ABBREVIATIONS dictionary
USPS_ABBREVIATIONS = {**STREET_ABBREVIATIONS, **UNIT_ABBREVIATIONS, **DIRECTIONAL_ABBREVIATIONS, **ORDINAL_ABBREVIATIONS}




import re

# Unified dictionary of abbreviations (merge all categories)
ABBREVIATIONS = {
    **STREET_ABBREVIATIONS,
    **UNIT_ABBREVIATIONS,
    **DIRECTIONAL_ABBREVIATIONS,
    **ORDINAL_ABBREVIATIONS,
    **US_STATE_ABBREVIATIONS,
    **CANADIAN_PROVINCE_ABBREVIATIONS
}

# Country Abbreviations
COUNTRY_ABBREVIATIONS = {
    "united states": "USA",
    "united states of america": "USA",
    "canada": "Canada",
}

# **Fix: Improved regex to detect both full & abbreviated unit designations (e.g., "Ste 22", "Suite 300", "Apt 5")**
UNIT_TERMS = list(UNIT_ABBREVIATIONS.keys()) + list(UNIT_ABBREVIATIONS.values())  # Include both full & abbreviations
UNIT_REGEX = re.compile(r"\b(" + "|".join(re.escape(term) for term in UNIT_TERMS) + r")\s*\d+\b", re.IGNORECASE)

def extract_unit(text):
    """Extracts and normalizes unit designations from the address before further processing."""
    match = UNIT_REGEX.search(text)
    if match:
        unit = match.group(0)  # Extract full unit (e.g., "Suite 300" or "Ste 22")
        
        # Convert full terms to their abbreviation if needed
        for full_word, abbreviation in UNIT_ABBREVIATIONS.items():
            unit = re.sub(r"\b" + re.escape(full_word) + r"\b", abbreviation, unit, flags=re.IGNORECASE)
        
        text = text.replace(match.group(0), "").strip()  # Remove unit from main address
        return text, unit.title()  # Ensure proper formatting for unit
    return text, None  # Return None if no unit is found

def extract_street_address(text):
    """Extracts the street address (street number + name)."""
    if text is None:
        return "", text

    # Match pattern: Starts with a number, followed by words, ending in a valid street type
    street_pattern = re.compile(r"^(\d+[A-Za-z]?)\s+([\w\s]+?)\s+(" + "|".join(re.escape(k) for k in STREET_ABBREVIATIONS.keys()) + r")\b", re.IGNORECASE)

    match = street_pattern.search(text)
    if match:
        street_number = match.group(1)
        street_name = match.group(2)
        street_type = match.group(3)

        # Construct proper street name
        full_street = f"{street_number} {street_name} {STREET_ABBREVIATIONS.get(street_type.lower(), street_type)}".strip()
        remaining_text = text.replace(match.group(0), "").strip()  # Remove street portion
        return full_street, remaining_text if remaining_text else ""

    return "", text  # If no match, return the original text

def extract_state_country(text):
    """Extracts state and country from the remaining address text."""
    words = text.split()
    country, state = None, None

    # Iterate through words backward to find country and state
    for i in range(len(words) - 1, -1, -1):
        word = words[i].lower()

        if word in COUNTRY_ABBREVIATIONS:
            country = COUNTRY_ABBREVIATIONS[word]
            words.pop(i)
        elif word in US_STATE_ABBREVIATIONS or word in CANADIAN_PROVINCE_ABBREVIATIONS:
            state = ABBREVIATIONS.get(word.upper(), word.upper())
            words.pop(i)

    # The remaining text is whatever is left after extracting state and country
    remaining_text = " ".join(words).title() if words else ""

    return state, country, remaining_text

def normalize_address(text):
    """Extracts structured components: unit, street, state, and country."""
    if text is None:
        return "", "", "", ""

    text = re.sub(r"[^\w\s,]", "", text)  # Remove excessive punctuation

    # **Step 1: Extract unit BEFORE modifying text**
    text, unit = extract_unit(text)

    # **Step 2: Extract street address**
    street_address, remaining_text = extract_street_address(text)

    # **Step 3: Extract state and country**
    state, country, remaining_text = extract_state_country(remaining_text)

    return street_address, state, country, unit

# Example addresses
example_addresses = [
    "Apartment 12, 123 Main Street Alberta Canada",
    "456 Boulevard Ave Suite 300 California United States",
    "789 Crescent DR Apt 5 New York USA",
    "100 Annex Rd Unit 47 British Columbia Canada",
    "350 Maple Drive Ste 22 Florida United States",
    "200 Highway 7 Quebec Canada"
]

# Apply normalization
for original in example_addresses:
    street_address, state, country, extracted_unit = normalize_address(original)
    print(f"Original: {original}")
    print(f"Street Address: {street_address if street_address else 'None'}")
    print(f"State: {state if state else 'None'}")
    print(f"Country: {country if country else 'None'}")
    print(f"Extracted Unit: {extracted_unit if extracted_unit else 'None'}")
    print("-" * 60)

import usaddress
import re
import usaddress

# Unit Designation Abbreviations (USPS Standard)
UNIT_ABBREVIATIONS = {
    "apartment": "Apt", "apt": "Apt", 
    "building": "Bldg", "bldg": "Bldg",
    "department": "Dept", "dept": "Dept",
    "floor": "Fl", "fl": "Fl",
    "front": "Frnt", "frnt": "Frnt",
    "hanger": "Hngr", "hngr": "Hngr",
    "lobby": "Lbby", "lbby": "Lbby",
    "lot": "Lot",
    "lower": "Lowr", "lowr": "Lowr",
    "office": "Ofc", "ofc": "Ofc",
    "penthouse": "Ph", "ph": "Ph",
    "pier": "Pier",
    "rear": "Rr", "rr": "Rr",
    "room": "Rm", "rm": "Rm",
    "side": "Side",
    "slip": "Slip",
    "space": "Spc",
    "stop": "Stop",
    "suite": "Ste", "ste": "Ste",
    "trailer": "Trlr", "trlr": "Trlr",
    "unit": "Unit",
    "upper": "Uppr", "uppr": "Uppr"
}

# **Fix: Make sure regex detects both full & abbreviated unit terms**
UNIT_TERMS = list(UNIT_ABBREVIATIONS.keys()) + list(UNIT_ABBREVIATIONS.values())  # Includes both full & abbreviations
UNIT_REGEX = re.compile(r"\b(" + "|".join(re.escape(term) for term in UNIT_TERMS) + r")\s*\d+\b", re.IGNORECASE)

def extract_unit(text):
    """Extracts and normalizes unit designations from the address."""
    match = UNIT_REGEX.search(text)
    if match:
        unit = match.group(0)  # Extract full unit (e.g., "Suite 300" or "Ste 22")
        
        # Convert to standardized abbreviation
        for full_word, abbreviation in UNIT_ABBREVIATIONS.items():
            unit = re.sub(r"\b" + re.escape(full_word) + r"\b", abbreviation, unit, flags=re.IGNORECASE)
        
        text = text.replace(match.group(0), "").strip()  # Remove unit from main address
        return text, unit.title()  # Ensure proper formatting for unit
    return text, None  # Return None if no unit is found

def parse_us_address(address):
    """Parses a U.S. address into structured components using usaddress, with added unit extraction."""
    try:
        # **Step 1: Extract the Unit before parsing the rest**
        address, extracted_unit = extract_unit(address)

        # **Step 2: Use `usaddress` to parse remaining address**
        parsed_address = usaddress.tag(address)[0]  

        return {
            "Addressee": parsed_address.get("Recipient", None),
            "Street Number": parsed_address.get("AddressNumber", None),
            "Street Name": " ".join(filter(None, [
                parsed_address.get("StreetNamePreDirectional", ""),
                parsed_address.get("StreetName", ""),
                parsed_address.get("StreetNamePostType", "")
            ])).strip(),
            "Unit": extracted_unit,  # **Fix: Always capture unit**
            "City": parsed_address.get("PlaceName", None),
            "State": parsed_address.get("StateName", None),
            "Zip Code": parsed_address.get("ZipCode", None),
            "Country": "USA"
        }

    except usaddress.RepeatedLabelError as e:
        print(f"Error parsing address: {address} â†’ {e}")
        return None

# **Example addresses to parse (with units)**
us_addresses = [
    "John Doe, 1234 Main St Apt 12, San Francisco, CA 94103",
    "4567 Elm Ave Suite 300, Los Angeles, CA 90001",
    "789 Broadway Ste 500, New York, NY 10001",  # **Fix: Now detects "Ste 500"**
    "200 Grand Blvd Unit 47, Chicago, IL 60607",
    "1000 Lake Shore Dr PH 2, Miami, FL 33139"
]

# **Apply address parsing**
for address in us_addresses:
    parsed_result = parse_us_address(address)
    print(f"Original Address: {address}")
    print(f"Parsed Components: {parsed_result}")
    print("-" * 60)
